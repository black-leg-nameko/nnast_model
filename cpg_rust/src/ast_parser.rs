//! AST parsing utilities
//!
//! This module handles parsing Python source code into AST and converting it
//! to a format that can be processed by Rust.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// AST node representation for Rust processing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ASTNode {
    /// Node type (e.g., "Module", "FunctionDef", "Name", etc.)
    pub node_type: String,
    /// Span information: (start_line, start_col, end_line, end_col)
    pub span: Option<(u32, u32, u32, u32)>,
    /// Symbol name (for functions, classes, variables, etc.)
    pub symbol: Option<String>,
    /// Type annotation (as string)
    pub type_hint: Option<String>,
    /// Node-specific attributes
    pub attrs: HashMap<String, String>,
    /// Child nodes
    pub children: Vec<ASTNode>,
    /// Context information (Load, Store, Del for Name nodes)
    pub ctx: Option<String>,
}

/// Parse Python source code
///
/// This function expects a JSON string representing the AST, which should be
/// generated by Python's ast.parse() and converted to JSON format.
///
/// # Arguments
/// * `ast_json` - JSON string representing the Python AST
///
/// # Returns
/// Parsed AST node or error
pub fn parse_ast_from_json(ast_json: &str) -> Result<ASTNode, Box<dyn std::error::Error>> {
    let node: ASTNode = serde_json::from_str(ast_json)?;
    Ok(node)
}

/// Calculate span from Python AST node information
///
/// # Arguments
/// * `lineno` - Line number (1-based, optional)
/// * `col_offset` - Column offset (0-based, optional)
/// * `end_lineno` - End line number (1-based, optional)
/// * `end_col_offset` - End column offset (0-based, optional)
/// * `total_lines` - Total number of lines in source
/// * `last_line_len` - Length of last line
///
/// # Returns
/// Span tuple (start_line, start_col, end_line, end_col) or None
pub fn calculate_span(
    lineno: Option<u32>,
    col_offset: Option<u32>,
    end_lineno: Option<u32>,
    end_col_offset: Option<u32>,
    total_lines: usize,
    last_line_len: usize,
) -> Option<(u32, u32, u32, u32)> {
    // Handle Module node specially
    if lineno.is_none() {
        let end_col = last_line_len as u32;
        return Some((1, 0, total_lines.max(1) as u32, end_col));
    }

    let start_line = lineno?;
    let start_col = col_offset.unwrap_or(0);
    let end_line = end_lineno.unwrap_or(start_line);
    let end_col = end_col_offset.unwrap_or(start_col);

    Some((start_line, start_col, end_line, end_col))
}

/// Map Python AST node type to CPG kind
pub fn node_type_to_kind(node_type: &str) -> &'static str {
    match node_type {
        "Module" => "Module",
        "FunctionDef" | "AsyncFunctionDef" => "Function",
        "ClassDef" => "Class",
        "With" | "AsyncWith" => "With",
        "Try" => "Try",
        "ExceptHandler" => "Except",
        "Assign" => "Assign",
        "AnnAssign" => "AnnAssign",
        "AugAssign" => "AugAssign",
        "Return" => "Return",
        "Call" => "Call",
        "Name" => "Name",
        "Attribute" => "Attribute",
        "Constant" => "Literal",
        "arg" => "Arg",
        "arguments" => "Arguments",
        "JoinedStr" => "JoinedStr",
        "FormattedValue" => "FormattedValue",
        "ListComp" => "ListComp",
        "SetComp" => "SetComp",
        "DictComp" => "DictComp",
        "GeneratorExp" => "Generator",
        "AsyncFor" => "AsyncFor",
        "Await" => "Await",
        "For" => "For",
        "While" => "While",
        "If" => "If",
        "IfExp" => "IfExp",
        "Break" => "Break",
        "Continue" => "Continue",
        "Pass" => "Pass",
        "Expr" => "Expr",
        "BinOp" => "BinOp",
        "UnaryOp" => "UnaryOp",
        "Compare" => "Compare",
        "BoolOp" => "BoolOp",
        "Subscript" => "Subscript",
        "Slice" => "Slice",
        "List" => "List",
        "Tuple" => "Tuple",
        "Set" => "Set",
        "Dict" => "Dict",
        "Lambda" => "Lambda",
        "Yield" => "Yield",
        "YieldFrom" => "YieldFrom",
        "Global" => "Global",
        "Nonlocal" => "Nonlocal",
        "Import" => "Import",
        "ImportFrom" => "ImportFrom",
        "Raise" => "Raise",
        "Assert" => "Assert",
        "Delete" => "Delete",
        // Context nodes (not statements)
        "Load" => "Load",
        "Store" => "Store",
        "Del" => "Del",
        _ => "Stmt",
    }
}

/// Extract symbol name from AST node
pub fn extract_symbol(node: &ASTNode) -> Option<String> {
    // Check if symbol is directly in the node
    if let Some(ref symbol) = node.symbol {
        return Some(symbol.clone());
    }

    // For some node types, we might need to extract from children
    // This will be handled by the builder when processing specific node types
    None
}

/// Extract type hint from AST node
pub fn extract_type_hint(node: &ASTNode) -> Option<String> {
    node.type_hint.clone()
}

/// Check if node is a statement (affects CFG construction)
pub fn is_statement(node_type: &str) -> bool {
    matches!(
        node_type,
        "FunctionDef"
            | "AsyncFunctionDef"
            | "ClassDef"
            | "Return"
            | "Delete"
            | "Assign"
            | "AnnAssign"
            | "AugAssign"
            | "For"
            | "AsyncFor"
            | "While"
            | "If"
            | "With"
            | "AsyncWith"
            | "Raise"
            | "Try"
            | "Assert"
            | "Import"
            | "ImportFrom"
            | "Global"
            | "Nonlocal"
            | "Expr"
            | "Pass"
            | "Break"
            | "Continue"
    )
}

/// Check if node is a control structure
pub fn is_control_structure(node_type: &str) -> bool {
    matches!(
        node_type,
        "If" | "For" | "AsyncFor" | "While" | "Try" | "With" | "AsyncWith"
    )
}

/// Check if node defines a new scope
pub fn defines_scope(node_type: &str) -> bool {
    matches!(node_type, "FunctionDef" | "AsyncFunctionDef" | "ClassDef" | "Lambda")
}

/// Check if node is a comprehension
pub fn is_comprehension(node_type: &str) -> bool {
    matches!(
        node_type,
        "ListComp" | "SetComp" | "DictComp" | "GeneratorExp"
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_node_type_to_kind() {
        assert_eq!(node_type_to_kind("FunctionDef"), "Function");
        assert_eq!(node_type_to_kind("Name"), "Name");
        assert_eq!(node_type_to_kind("Unknown"), "Stmt");
    }

    #[test]
    fn test_calculate_span() {
        let span = calculate_span(Some(10), Some(5), Some(10), Some(15), 100, 80);
        assert_eq!(span, Some((10, 5, 10, 15)));

        let span = calculate_span(None, None, None, None, 100, 80);
        assert_eq!(span, Some((1, 0, 100, 80))); // Module node
    }

    #[test]
    fn test_is_statement() {
        assert!(is_statement("Return"));
        assert!(is_statement("Assign"));
        assert!(!is_statement("Name"));
        assert!(!is_statement("Constant"));
    }

    #[test]
    fn test_is_control_structure() {
        assert!(is_control_structure("If"));
        assert!(is_control_structure("For"));
        assert!(!is_control_structure("Return"));
    }

    #[test]
    fn test_defines_scope() {
        assert!(defines_scope("FunctionDef"));
        assert!(defines_scope("Lambda"));
        assert!(!defines_scope("If"));
    }
}
